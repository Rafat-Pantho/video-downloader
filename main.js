const { app, BrowserWindow, ipcMain, dialog, session } = require('electron');
const path = require('path');
const { exec, spawn } = require('child_process');
const { promisify } = require('util');
const fs = require('fs');
const os = require('os');

const execPromise = promisify(exec);

// Disable GPU cache to prevent cache errors
app.commandLine.appendSwitch('disable-gpu-shader-disk-cache');

// Get bundled yt-dlp path
function getYtDlpPath() {
  // In production, use bundled yt-dlp
  if (app.isPackaged) {
    const ytdlpPath = path.join(process.resourcesPath, 'app.asar.unpacked', 'bin', 'yt-dlp.exe');
    if (fs.existsSync(ytdlpPath)) {
      return ytdlpPath;
    }
  }
  
  // In development, use bin folder
  const devPath = path.join(__dirname, 'bin', 'yt-dlp.exe');
  if (fs.existsSync(devPath)) {
    return devPath;
  }
  
  // Fallback to system yt-dlp
  return 'yt-dlp';
}

// Get bundled ffmpeg path
function getFFmpegPath() {
  // In production
  if (app.isPackaged) {
    const ffmpegPath = path.join(process.resourcesPath, 'app.asar.unpacked', 'bin', 'ffmpeg.exe');
    if (fs.existsSync(ffmpegPath)) {
      return path.dirname(ffmpegPath);
    }
  }
  
  // In development
  const devPath = path.join(__dirname, 'bin', 'ffmpeg.exe');
  if (fs.existsSync(devPath)) {
    return path.dirname(devPath);
  }
  
  // Fallback to system PATH
  return null;
}

const YTDLP_PATH = getYtDlpPath();
const FFMPEG_DIR = getFFmpegPath();

// Cookie storage paths
const COOKIES_DIR = path.join(app.getPath('userData'), 'cookies');
const COOKIES_PATH = path.join(COOKIES_DIR, 'cookies.txt');

// Ensure cookies directory exists
if (!fs.existsSync(COOKIES_DIR)) {
  fs.mkdirSync(COOKIES_DIR, { recursive: true });
}

let mainWindow;
let loginWindow = null;

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 900,
    height: 700,
    minWidth: 700,
    minHeight: 600,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false
    },
    icon: path.join(__dirname, 'assets', 'icon.png'),
    backgroundColor: '#f3e5f5',
    show: false,
    autoHideMenuBar: true
  });

  mainWindow.loadFile('react-index.html');

  mainWindow.once('ready-to-show', () => {
    mainWindow.show();
  });

  mainWindow.on('closed', () => {
    mainWindow = null;
  });
}

// Create login window for cookie capture
function createLoginWindow(url) {
  if (loginWindow) {
    loginWindow.focus();
    return;
  }

  // Determine which domain to use based on URL
  let loginUrl = url;
  if (url.includes('youtube.com') || url.includes('youtu.be')) {
    loginUrl = 'https://accounts.google.com/ServiceLogin?continue=https://www.youtube.com/';
  } else if (url.includes('facebook.com') || url.includes('fb.watch')) {
    loginUrl = 'https://www.facebook.com/login/';
  } else if (url.includes('instagram.com')) {
    loginUrl = 'https://www.instagram.com/accounts/login/';
  } else if (url.includes('twitter.com') || url.includes('x.com')) {
    loginUrl = 'https://twitter.com/i/flow/login';
  }

  loginWindow = new BrowserWindow({
    width: 800,
    height: 600,
    parent: mainWindow,
    modal: true,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      partition: 'persist:login' // Persistent session for cookies
    },
    title: 'Login to continue',
    autoHideMenuBar: true
  });

  loginWindow.loadURL(loginUrl);

  loginWindow.on('closed', () => {
    loginWindow = null;
  });

  // Save cookies when window is closed or after successful login
  loginWindow.webContents.on('did-navigate', async () => {
    await saveCookiesFromSession();
  });

  return loginWindow;
}

// Save cookies from login session to Netscape format
async function saveCookiesFromSession() {
  try {
    const loginSession = session.fromPartition('persist:login');
    const cookies = await loginSession.cookies.get({});
    
    if (cookies.length === 0) {
      return { success: false, message: 'No cookies found' };
    }

    // Convert to Netscape cookies.txt format
    let cookieContent = '# Netscape HTTP Cookie File\n';
    cookieContent += '# This file was generated by Video Downloader. Edit at your own risk.\n\n';
    
    for (const cookie of cookies) {
      const domain = cookie.domain.startsWith('.') ? cookie.domain : `.${cookie.domain}`;
      const flag = cookie.domain.startsWith('.') ? 'TRUE' : 'FALSE';
      const path = cookie.path || '/';
      const secure = cookie.secure ? 'TRUE' : 'FALSE';
      const expiration = cookie.expirationDate ? Math.floor(cookie.expirationDate) : '0';
      const name = cookie.name;
      const value = cookie.value;

      cookieContent += `${domain}\t${flag}\t${path}\t${secure}\t${expiration}\t${name}\t${value}\n`;
    }

    // Save to cookies.txt
    fs.writeFileSync(COOKIES_PATH, cookieContent, 'utf-8');
    
    return { success: true, count: cookies.length };
  } catch (error) {
    console.error('Error saving cookies:', error);
    return { success: false, message: error.message };
  }
}

app.whenReady().then(createWindow);

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// IPC Handlers

// Check yt-dlp installation
ipcMain.handle('check-ytdlp', async () => {
  try {
    const { stdout } = await execPromise(`"${YTDLP_PATH}" --version`);
    return { installed: true, version: stdout.trim() };
  } catch (error) {
    return { installed: false, version: null };
  }
});

// Install yt-dlp (not needed with bundled version, but kept for compatibility)
ipcMain.handle('install-ytdlp', async () => {
  // Since we bundle yt-dlp, just check if it exists
  if (fs.existsSync(YTDLP_PATH)) {
    return { success: true };
  }
  return { success: false, error: 'Bundled yt-dlp not found' };
});

// Get video info
ipcMain.handle('get-video-info', async (event, url) => {
  try {
    // Use spawn instead of exec to handle stderr warnings properly
    const result = await new Promise((resolve, reject) => {
      const args = [
        '--no-playlist',  // Only get info for single video, not entire playlist
        '--no-warnings',  // Reduce noise from warnings
        '--get-title', 
        '--get-duration', 
        '--get-thumbnail'
      ];
      
      // Add cookies if available
      if (fs.existsSync(COOKIES_PATH)) {
        args.push('--cookies', COOKIES_PATH);
      }
      
      args.push(url);
      
      const childProcess = spawn(YTDLP_PATH, args, {
        timeout: 60000,  // Increased to 60 seconds for slower platforms
        env: { ...process.env, PATH: `${FFMPEG_DIR};${process.env.PATH}` }
      });
      
      let stdout = '';
      let stderr = '';
      
      childProcess.stdout.on('data', (data) => {
        stdout += data.toString();
      });
      
      childProcess.stderr.on('data', (data) => {
        stderr += data.toString();
      });
      
      childProcess.on('close', (code) => {
        // YouTube warnings are sent to stderr but don't indicate failure
        // Only reject if exit code is non-zero AND we got no stdout
        if (code !== 0 && !stdout.trim()) {
          // Provide better error messages based on the error content
          let errorMsg = stderr || `Process exited with code ${code}`;
          if (stderr.includes('Cannot parse data')) {
            errorMsg = 'Unable to extract video info. The platform may require login or the link may be invalid.';
          } else if (stderr.includes('Unsupported URL')) {
            errorMsg = 'This URL is not supported by yt-dlp.';
          } else if (stderr.includes('Video unavailable')) {
            errorMsg = 'This video is unavailable or private.';
          } else if (stderr.includes('This video requires payment')) {
            errorMsg = 'This video requires payment to access.';
          }
          reject(new Error(errorMsg));
        } else {
          resolve({ stdout, stderr });
        }
      });
      
      childProcess.on('error', reject);
    });
    
    const lines = result.stdout.trim().split('\n');
    return {
      success: true,
      title: lines[0]?.replace(/[<>:"/\\|?*]/g, '_').substring(0, 100) || 'video',
      duration: lines[1] || 'Unknown',
      thumbnail: lines[2] || null
    };
  } catch (error) {
    return {
      success: false,
      title: generateRandomName(),
      error: error.message
    };
  }
});

// Select folder dialog
ipcMain.handle('select-folder', async () => {
  const result = await dialog.showOpenDialog(mainWindow, {
    properties: ['openDirectory'],
    defaultPath: path.join(os.homedir(), 'Downloads')
  });
  
  if (result.canceled) {
    return null;
  }
  return result.filePaths[0];
});

// Download video
ipcMain.handle('download-video', async (event, { url, folder, filename, format, quality }) => {
  return new Promise((resolve, reject) => {
    const outputPath = path.join(folder, `${filename}.%(ext)s`);
    
    // Build format string based on quality
    let formatString;
    switch(quality) {
      case 'best':
        formatString = 'bestvideo+bestaudio/best';
        break;
      case '1080p':
        formatString = 'bestvideo[height<=1080]+bestaudio/best[height<=1080]';
        break;
      case '720p':
        formatString = 'bestvideo[height<=720]+bestaudio/best[height<=720]';
        break;
      case '480p':
        formatString = 'bestvideo[height<=480]+bestaudio/best[height<=480]';
        break;
      case 'audio':
        formatString = 'bestaudio/best';
        break;
      default:
        formatString = 'bestvideo+bestaudio/best';
    }
    
    const args = [
      '--format', formatString,
      '--merge-output-format', format,
      '--output', outputPath,
      '--no-playlist',
      '--progress',
      '--newline',
      // Embed metadata
      '--embed-metadata',
      url
    ];

    // Add cookies if available
    if (fs.existsSync(COOKIES_PATH)) {
      args.splice(args.length - 1, 0, '--cookies', COOKIES_PATH);
    }

    // Add ffmpeg location if available
    if (FFMPEG_DIR) {
      const ffmpegExe = path.join(FFMPEG_DIR, 'ffmpeg.exe');
      args.splice(args.length - 1, 0, '--ffmpeg-location', ffmpegExe);
    }

    // Set ffmpeg location if we have bundled version
    const spawnOptions = {};
    if (FFMPEG_DIR) {
      spawnOptions.env = {
        ...process.env,
        PATH: `${FFMPEG_DIR};${process.env.PATH}`
      };
    }

    const ytdlp = spawn(YTDLP_PATH, args, spawnOptions);
    let lastProgress = 0;

    ytdlp.stdout.on('data', (data) => {
      const text = data.toString().trim();
      if (text.includes('[download]') && text.includes('%')) {
        const match = text.match(/(\d+\.?\d*)%/);
        if (match) {
          const progress = parseFloat(match[1]);
          if (progress > lastProgress) {
            lastProgress = progress;
            event.sender.send('download-progress', { progress, message: text });
          }
        }
      }
    });

    let errorMessages = '';

    ytdlp.stderr.on('data', (data) => {
      const text = data.toString();
      errorMessages += text;
      if (text.includes('ERROR')) {
        event.sender.send('download-error', text);
      }
    });

    ytdlp.on('close', (code) => {
      if (code === 0) {
        const finalPath = path.join(folder, `${filename}.${format}`);
        let size = null;
        if (fs.existsSync(finalPath)) {
          size = (fs.statSync(finalPath).size / 1024 / 1024).toFixed(2);
        }
        resolve({ success: true, path: finalPath, size });
      } else {
        // Check for specific error types that require login
        const needsLogin = errorMessages.includes('This video is private') ||
                          errorMessages.includes('This video requires payment') ||
                          errorMessages.includes('members-only') ||
                          errorMessages.includes('age-restricted') ||
                          errorMessages.includes('Sign in to confirm your age') ||
                          errorMessages.includes('This live stream recording is not available') ||
                          errorMessages.includes('This video is unavailable');
        
        if (needsLogin) {
          resolve({ 
            success: false, 
            needsLogin: true,
            url: url,
            error: 'This video requires login. Click "Login" to authenticate.' 
          });
        } else {
          resolve({ 
            success: false, 
            error: 'Download failed. The video may be unavailable, private, or restricted.' 
          });
        }
      }
    });

    ytdlp.on('error', (err) => {
      resolve({ 
        success: false, 
        error: 'Failed to run yt-dlp. Make sure it is installed.' 
      });
    });
  });
});

// Open folder in explorer
ipcMain.handle('open-folder', async (event, folderPath) => {
  try {
    if (process.platform === 'win32') {
      exec(`explorer "${folderPath}"`);
    } else if (process.platform === 'darwin') {
      exec(`open "${folderPath}"`);
    } else {
      exec(`xdg-open "${folderPath}"`);
    }
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Login and cookie management handlers
ipcMain.handle('open-login-window', async (event, url) => {
  try {
    createLoginWindow(url);
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle('close-login-window', async () => {
  try {
    if (loginWindow) {
      // Save cookies before closing
      await saveCookiesFromSession();
      loginWindow.close();
      loginWindow = null;
    }
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle('load-cookies', async () => {
  try {
    if (fs.existsSync(COOKIES_PATH)) {
      const content = fs.readFileSync(COOKIES_PATH, 'utf-8');
      return { success: true, content };
    }
    return { success: true, content: '' };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle('save-cookies', async (event, cookiesContent) => {
  try {
    fs.writeFileSync(COOKIES_PATH, cookiesContent, 'utf-8');
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle('check-login-status', async () => {
  try {
    if (fs.existsSync(COOKIES_PATH)) {
      const content = fs.readFileSync(COOKIES_PATH, 'utf-8');
      const cookieLines = content.split('\n').filter(line => 
        line.trim() && !line.startsWith('#')
      );
      
      // Extract unique domains from cookies
      const domains = [...new Set(cookieLines.map(line => {
        const parts = line.split('\t');
        if (parts.length >= 1) {
          return parts[0].replace(/^\./, ''); // Remove leading dot
        }
        return null;
      }).filter(d => d))];
      
      return { 
        success: true, 
        loggedIn: cookieLines.length > 0,
        domains: domains,
        cookieCount: cookieLines.length
      };
    }
    return { success: true, loggedIn: false, domains: [], cookieCount: 0 };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle('clear-cookies', async () => {
  try {
    // Clear saved cookies file
    if (fs.existsSync(COOKIES_PATH)) {
      fs.unlinkSync(COOKIES_PATH);
    }
    
    // Clear session cookies
    const loginSession = session.fromPartition('persist:login');
    await loginSession.clearStorageData({
      storages: ['cookies']
    });
    
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

// Helper function
function generateRandomName() {
  return Math.random().toString(36).substring(2, 8).toUpperCase();
}
